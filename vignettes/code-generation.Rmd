---
title: "Code generation"
author: "Carson Sievert & Joe Cheng"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    self_contained: false
vignette: >
  %\VignetteIndexEntry{1. Code generation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  fig.align = "center",
  out.width = "80%",
  class.output = "R",
  comment = ""
)
library(shiny)
library(shinymeta)
library(dplyr)
library(ggplot2)
options(shiny.suppressMissingContextError = TRUE)
input <- list(package = "ggplot2")
output <- list()

# Only show the first few rows
library(knitr)
knit_print.data.frame <- function(x, ...) {
  if (nrow(x) > 10) {
    normal_print(head(x, 6))
    cat("[...plus", nrow(x) - 6, "more rows...]\n")
  }
}
# register the method
registerS3method("knit_print", "data.frame", knit_print.data.frame)
```

```{css echo=FALSE}
pre {
  border: 1px solid #eee;
}

pre.r {
  background-color: #ffffff;
}

pre.r code {
  background-color: #ffffff;
}

pre.R {
  background-color: #f8f8f8;
  border-radius: 0px;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
}

.sourceCode .R {
  margin-top: -1em;
}
```

Here's a reduced version of the [cranview](https://github.com/cpsievert/cranview) Shiny app that allows you to enter an R package name to generate a plot of its [CRAN](https://cran.r-project.org/) downloads over the past year. This app provides a nice example of how to modify an existing Shiny app so that it can generate code to reproduce what a user sees in the app:

```{r, eval = FALSE}
library(shiny)
library(ggplot2)
library(dplyr)

ui <- fluidPage(
  textInput("package", "Package name", value = "ggplot2"),
  plotOutput("plot")
)

server <- function(input, output, session) {
  
  downloads <- reactive({
    # Retrieve a year's worth of daily download data
    cranlogs::cran_downloads(input$package, from = Sys.Date() - 365, to = Sys.Date())
  })
  
  downloads_rolling <- reactive({
    # Show the user an informative message if there are no download counts
    validate(need(sum(downloads()$count) > 0, "Input a valid package name"))
    # Convert daily data to 7 day rolling average
    downloads() %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
  })
  
  output$plot <- renderPlot({
    ggplot(downloads_rolling(), aes(date, count)) + geom_line() + ggtitle("Seven day rolling average")
  })
}

shinyApp(ui, server)
```

Below is one way the app above could be modified to generate code that reproduces `output$plot` outside of the shiny session. Notice how both the `output$plot` and `output$code` update dynamically in response to new package names without having to repeat any logic of the original app. To keep the focus on code generation, we've presented the `output$code` as simple as possible here (by using `verbatimTextOutput()` and `renderPrint()`), but the [next article](code-distribution.html) outlines the various options distributing code to users.

```{r, eval = FALSE}
library(shiny)
library(ggplot2)
library(dplyr)
library(shinymeta)

ui <- fluidPage(
  textInput("package", "Package name", value = "ggplot2"),
  verbatimTextOutput("code"),
  plotOutput("plot")
)

server <- function(input, output, session) {
  downloads <- metaReactive({
    "# Retrieve a year's worth of daily download data"
    cranlogs::cran_downloads(..(input$package), from = Sys.Date() - 365, to = Sys.Date())
  })
  
  downloads_rolling <- metaReactive2({
    validate(need(sum(downloads()$count) > 0, "Input a valid package name"))
    
    metaExpr({
      "# Convert daily data to 7 day rolling average"
      ..(downloads()) %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
    })
  })
  
  output$plot <- metaRender(renderPlot, {
      ggplot(..(downloads_rolling()), aes(date, count)) + geom_line() + ggtitle("Seven day rolling average")
  })
  
  output$code <- renderPrint({
    expandChain(
      quote(library(ggplot2)), 
      output$plot()
    )
  })
}

shinyApp(ui, server)
```

```{r, echo = FALSE}
knitr::include_graphics("https://i.imgur.com/T9a60Fm.gif")
```

So, what has changed in the implementation between the original Shiny app and the one that generates code? There a few high-level observations we can make here that should hold true for most apps that leverage **shinymeta** to generate code:

* Each reactive building block (e.g., `reactive()`, `renderPlot()`, etc) has been replaced by a meta-variant (e.g., `metaReactive()`, `metaRender()`, etc). All code within these meta-variants are considered to be "domain logic" (i.e. code that you'd like to export).
  * In situations where part of the code *isn't* domain logic, **shinymeta** provides a second version (e.g. `metaReactive2()`, `metaRender2()`, etc) that allows you to completely [ignore non-domain logic](#ignore-code) (by wrapping only the code you care about in `metaExpr()`).
  * This example doesn't have `observe()`, but these [covers their meta variant as well](#observers).
* Each read of a meta-reactive or an `input` value has been wrapped in `..()`.
* Comments are retained by surrounding them in quotes.
* The output of interest (`output$plot`) is invoked inside `expandChain()`, which generates code to reproduce that output.
    * `expandChain()` also accepts `quote()`d expressions, which allows you to supply any setup code that the user might need (for example, loading of libraries).

For most existing Shiny applications, you should be able to apply these changes, and the code generation should "just work". In some scenarios, however, you may have to adjust your Shiny app logic, and in doing so, it will payoff to have a more thorough understanding of how **shinymeta** works, especially when surrounding reactive reads in `..()`.  For part of the story, it will help to have some familiarity with metaprogramming (especially [quasi-quotation](https://adv-r.hadley.nz/quasiquotation.html)), but it shouldn't be necessary to gain a basic understanding of what's happening in  **shinymeta**.

## Meta execution

Meta-reactives (e.g., `metaReactive()`, `metaRender()`, etc) can be invoked in two different modes: meta or normal (the default). In normal execution, the behavior of the meta-reactive is exactly the same as the non-meta version (e.g., `downloads()` still evaluates and caches results just like a normal `reactive()` does):

```{r}
downloads <- metaReactive({
  cranlogs::cran_downloads(input$package, from = Sys.Date() - 365, to = Sys.Date())
})
downloads()
```

On the other hand, when invoked in meta mode, meta-variants return a code expression instead of fully evaluating the expression (i.e., they quote their input). **shinymeta** currently provides two ways to invoke meta-reactives in meta mode: `withMetaMode()` and `expandChain()`. In practice, you'll almost always want to use `expandChain()` over `withMetaMode()`: it has the added feature of assigning return values to a name and intelligently reusing names to avoid redundant computation when [generating code from a chain of reactives](#expandChain), but we'll start by using `withMetaMode()` here to facilitate discussion.

```{r}
withMetaMode(downloads())
```

Notice how the generated code here depends on the input variable `input$package`. If we were to run this code in a new R session, it would error because `input$package` isn't defined outside of the shiny session. We can, however, replace the literal name "`input$package`" with the value it represents by wrapping it in`..()` (which allows the resulting code expression to run an environment where `input` isn't defined). In simpler terms, __use `..()` to replace reactive values (e.g. `input$package`) with their static value__.

```{r}
downloads <- metaReactive({
  cranlogs::cran_downloads(..(input$package), from = Sys.Date() - 365, to = Sys.Date())
})
withMetaMode(downloads())
```

More generally, `..()` evaluates (i.e., unquotes) *anything* that appears inside of it when invoked in meta mode (we'll explore this idea further in the next section). On the other hand, in normal execution, the `..()` is ignored (think of it like `identity()`), which ensures your app behaves just as it would without **shinymeta** integration.

## Unquoting in general {#unquoting}

In computing, functions that return code expressions (e.g., `quote()`) are known as quoting functions. A quoting function that allow you to also evaluate (i.e., unquote) certain parts of an expression is known as a quasi-quoting function. Both base R's `bquote()` and **rlang**'s `expr()` are quasi-quoting functions. The former unquotes terms wrapped in `..()`  whereas the latter uses `!!`:

```{r}
a <- 2
quote(a + 1)
```

```{r}
bquote(.(a) + 1)
```

```{r}
rlang::expr(!!a + 1)
```

When meta-reactives are invoked in meta-mode, they perform quasi-quotation by evaluating terms wrapped in `..()`. We've already seen how `..()` can be used to replace reactive inputs with their static values (**note**: this also works with `reactiveVal()`/`reactiveValues()`), but you can put whatever you want inside `..()` so you can use it to have full control over the generated code. For example, by unquoting the value supplied to the `from` argument in `downloads()`, we'll inline the value that the code expression `Sys.Date() - 365` represents, so that when the generated code is run in the future, we always get downloads starting `from` a year prior to *the day the code was generated* (instead of a year prior to *the day the generated code is run*).

```{r}
# NOTE: there's an important difference between `..(Sys.Date()) - 365` and `..(Sys.Date() - 365)`!
downloads <- metaReactive({
  cranlogs::cran_downloads(..(input$package), from = ..(Sys.Date() - 365), to = Sys.Date())
})
withMetaMode(downloads())
```

At first, this result may be a little suprising (i.e., what's `structure()` doing there?), but it's necessary to retain any attributes (e.g. `class`) of unquoted objects. In this case, since the `from` argument accepts string in `"yyyy-mm-dd"` format (i.e., the `Date` class isn't necessary), we can use `format()` to coerce the `Date` object into a string (and thus, more human-readable).

```{r}
downloads <- metaReactive({
  cranlogs::cran_downloads(..(input$package), from = ..(format(Sys.Date() - 365)), to = Sys.Date())
})
withMetaMode(downloads())
```

Unquoting is fairly straightforward when the name you're unquoting (`e.g. input$package`) represents a constant value (e.g. `"ggplot2"`), but is a bit more complicated when those values become more complicated. 

In the next section, we'll be chaining meta-reactive expressions, which requires unquoting names that represent meta-reactives. That means, these names can actually be thought of as un-evaluated expressions!

## Unquoting reactive reads {#chaining}

Chaining of reactive expressions is a very useful pattern that allows Shiny to intelligently cache computations for you. Note that our example app has a reactive chain: the acquistion of daily downloads is done in one reactive expression, `downloads()`, then `downloads_rolling()` uses the return value of `downloads()` to compute a weekly rolling average. For now, let's imagine `download_rolling()` is implemented this way (in the next section, we'll cover actual implementation):

```{r}
downloads_rolling <- metaReactive({
  downloads() %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
})
```

Remember that, when invoked in meta-mode, `metaReactive()` quotes its input, which is why `downloads()` appears in the code produced by `downloads_rolling()`:

```{r}
withMetaMode(downloads_rolling())
```

So, similar to the problem we had before with `input$package`, the generated code relies on something that won't be defined in a new R session (`downloads()`). By unquoting `downloads()`, we can replace it with the value it represents: a code expression!

```{r}
downloads_rolling <- metaReactive({
  ..(downloads()) %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
})
withMetaMode(downloads_rolling())
```

> #### Takeaway: unquote meta-reactive reads (i.e., `..(downloads())`) that appear within other meta-reactives

## Ignoring non-domain logic {#ignore-code}

Recall that the actual implementation of `downloads_rolling()` uses Shiny's input validation helpers (e.g. `validate()`, `need()`, and `req()`) to relay an informative message to the user if they've input a package name that doesn't exist on CRAN:

```{r}
downloads_rolling <- reactive({
  validate(need(sum(downloads()$count) > 0, "Input a valid package name"))
  downloads() %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
})
```

Input validation is helpful improving the user experience of your shiny app, but it's irrelevant outside of a Shiny runtime context. For this reason, **shinymeta** provides a second version of each meta-reactive (e.g., `metaReactive2()`, `metaObserve2()`, `metaRender2()`, etc), which allows you to capture only the code you care about with `metaExpr()`. Inside these `-2` variants, only the meta-reactive reads inside `metaExpr()` undergo meta execution. In other words, in the example below, the read of `downloads()` that appears before `metaExpr()` *always* returns it's a data frame (the `validate()` wouldn't make sense if `downloads()` returned code!). 

```{r}
downloads_rolling <- metaReactive2({
  validate(need(sum(downloads()$count) > 0, "Input a valid package name"))
  
  metaExpr({
    ..(downloads()) %>% mutate(count = zoo::rollapply(count, 7, mean, fill = "extend"))
  })
})

withMetaMode(downloads_rolling())
```

When using these `-2` variants, make sure the return value of the expression is a `metaExpr()` object (In practice, the code you want to capture might depend on other input value(s). In that case, you can use control flow [similar to this](https://github.com/cpsievert/cranview/blob/f4989a9/app.R#L71-L89), just make sure to return a `metaExpr()`!).

## Other meta-reactives (observers & outputs) {#observers}

So far we've learned how to manage reactive values (e.g., `input$package`) and reactive expressions (e.g., `downloads()`), but what about code captured in the endpoints of shiny's reactivity model (i.e. observers and outputs)?

```{r, echo = FALSE, out.width="60%"}
knitr::include_graphics("reactivity-graph-00.png")
```

#### Observers

Creating a meta variant of `observe()` is very similar to creating a meta variant of `reactive()`: use `metaObserve()` instead of `observe()` and unquote any references to reactive values or expressions. Note that, outside of meta mode, `metaObserve()` behaves the same as `observe()`: it immediately evaluates the given expression (i.e., there's no need to invoke `msgObs()` outside of meta mode).

```{r}
msgObs <- metaObserve({
  message(..(input$package), " has an daily download average of ", mean(..(downloads())$count))
})
withMetaMode(msgObs())
```

The traditional `observe()` function returns an object that can be used to control aspects of the observer, though most Shiny apps don't bother to save it. See `?observe` for the different methods available. The object returned from `metaObserve()` can be used in the same way (`msgObs$suspend()`, for example) but has the additional capability of being called like a function, as in the previous code example.

#### Outputs

Since package authors are allowed to create their own output rendering functions, creating a meta variant of an output renderer (e.g. `renderPlot()`) needs to be more general than prefixing `meta` to the function name (as we did with `metaReactive()` and `metaObserve()`). Therefore, **shinymeta** has a general-purpose `metaRender()` function that anticipates a rendering function in it's first argument, and an expression in the second argument.^[`metaRender()` makes some assumptions about the arguments taken by the render function, assumptions that we believe are true for all existing render functions. If you encounter a render function that doesn't seem to work properly with **shinymeta**, please let us know by [filing an issue on GitHub](https://github.com/rstudio/shinymeta/issues).] Here's how we can make a meta variant of the CRAN downloads plot:

```{r}
output$plot <- metaRender(renderPlot, {
  ggplot(..(downloads_rolling()), aes(date, count)) + geom_line() + ggtitle("Seven day rolling average")
})
```

Similar to `metaReactive()` and `metaObserve()`, invoking an output inside `expandChain()` generates the code required to reproduce it.^[If meta mode is not enabled, `output$OUTPUT_ID()` will intentionally produce an error.]

```{r}
withMetaMode(output$plot())
```

## Expanding reactive chains {#expandChain}

In practice, you'll likely want to use `expandChain()` over `withMetaMode()`: it also invokes meta-reactives in meta-mode, but has the additional feature of assigning return values to a name and intelligently reusing names to avoid redundant computation. `expandChain()` also allows you to supply arbitrary quoted expressions, which is primarily useful for any setup code not captured in reactive expressions (e.g. loading of libraries):

```{r}
# add another output just to demonstrate
output$summary <- metaRender(renderPrint, {
  summary(..(downloads())$count)
})

expandChain(
  quote(library(ggplot2)),
  output$plot(),
  output$summary()
)
```

Note, however, that if we expand these outputs separately, `expandChain()` won't know to avoid duplicating code for dependencies that they share. In our case, both of these outputs depend on `downloads`, so if we expand them in subsequent calls to `expandChain()`, we'll be producing code that calls `cranlogs::cran_downloads()` twice:

```{r}
expandChain(output$plot())
```

```{r}
expandChain(output$summary())
```

Fortunately, there is a way to avoid this redundant code caused by shared dependencies by sharing an 'expansion context' between subsequent calls to `expandChain()`. This is especially useful for [generating reports](#generating-reports):

```{r}
ec <- newExpansionContext()
expandChain(output$plot(), .expansionContext = ec)
```

```{r}
expandChain(output$summary(), .expansionContext = ec)
```

Expansion contexts are also useful for cases where you need to redefine a meta-reactive's logic. This is useful in at least two scenarios:

1. For efficiency or privacy reasons, you may not want to provide the "rawest" form of the data in your app to users. Instead, you might want to only provide a transformed and/or summarized version of the data. For example, instead of providing the user with `downloads`, we could provide `downloads_rolling` as file to be [included as part of a download bundle](code-distribution.html#including-other-files).

```{r}
saveRDS(downloads_rolling(), "d.rds")
ec <- newExpansionContext()
ec$substituteMetaReactive(downloads_rolling, function() {
  metaExpr(readRDS("d.rds"))
})

expandChain(
  quote(library(ggplot2)),
  output$plot(),
  .expansionContext = ec
)
```

```{r, echo = FALSE}
unlink("d.rds")
```

2. Apps that allow users to upload a file: the location of the file on the server won't be available to users, so it may be easier just to substitute the reactive that reads the uploaded file. For an example, see [this example](code-distribution.html#including-other-files) in the next vignette.
